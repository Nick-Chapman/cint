
## Homework 6

So now we know all about writing interpreters. Time to think about compilation...

Specifically, compilation to a simple bytecode language.

### (1) Bytecode definition

Bytecode is a form of simple language for expressing computations, which is normally represented compactly as a sequence of bytes. But the essential aspect is that the code is a linear sequence of operations, with no _sub-expression_ structure.

Let's assume a very simple bytecode, which we model in Haskell with the following type.

```
type Code = [BC]
data BC = ADD | SUB | MUL | DUP | SWAP | PUSH Int deriving Show
```

#### Bytecode emulator

As we can see, this `Bytecode` type is very simple. All but one of the constructors are pure _enums_. Only the `PUSH` constructor carries a value to _push_. (In this example, all values are simple `Int`s)

The first thing we need is an _emulator_ for our bytecode.

```
runBC :: [BC] -> Int
runBC = undefined
```

Before we can write an emulator we need to understand what each bytecode operation means; how does bytecode execute?

Our bytecode targets a stack-machine. The opcodes in a sequence of bytecode execute from left to right. Each opcode, takes its arguments from, and pushes its result(s) to, a stack which is threaded through the computation. Before execution begins the stack is empty. When the bytecode execution is finished, the final result remains as the top value (the only value we hope!) on the stack.

The binary arithmetic operators `ADD`,`SUB` and `MUL` each pop two arguments of the stack, compute the result `top OP second`, and then push this result back on the stack. `DUP` takes the top stack item, duplicates it, and pushes back two copies on the stack. `SWAP` swaps the top two stack items. Finally `PUSH n` pushes the value `n` onto the stack.

#### example/test (bytecode emulator)

Here's a concrete example, along with the expected result:

```
  let code :: [BC] = [PUSH 7, DUP, PUSH 1, SWAP, SUB, MUL]
  print (expect 42 (runBC code))
```

Now, please implement `runBC`...

### (2) Expression language

While bytecode is a nice simple model of computation, it is not very human friendly. Humans prefer expressions. For example the following simple language, represented as a Haskell datatype. The language has literal numbers, a couple of binary arithmetic operators, and a unary squaring operator (raise to the power of 2).

```
data Exp = Num Int | Add Exp Exp | Sub Exp Exp | Square Exp
```

#### Expression Evaluator

Writing an evaluator for this language should be straightforward.

Please write `eval`...

```
eval :: Exp -> Int
eval = undefined
```

#### example/test (evaluation)

Again, here is a small concrete example, with the expected result:

```
  -- ( 3^2 + (5 - 4) )^2
  let exp :: Exp = Square (Add (Square (Num 3)) (Sub (Num 5) (Num 4)))
  print (expect 100 (eval exp))
```

### (3) Compilation

Now finally we reach the point of this homework. We should like to write a compiler from our expression language into a sequence of bytecode, such that the result of running the bytecode generated by the compiler has the identical behaviour as directly evaluating the expression: Formally `runBC . compile` _===_ `eval`. (`.` is function composition).

Please implement `compile`...

```
compile :: Exp -> [BC]
compile = undefined
```

#### example/test (compilation + emulation)

You should be able to use `compile` to generate bytecode for our running example, inspect it, and see that execution via the bytecode emulator gives the same value as directly using the evaluator.

```
  let compiled :: [BC] = compile exp
  print compiled
  print (expect 100 (runBC compiled))
```

### Misc

The `expect` function to make the code complete.

```
expect :: (Eq a, Show a) => a -> a -> a
expect a b = if a == b then a else
  error ("expect failed: " ++ show a ++ " not same as: " ++ show b)
```
